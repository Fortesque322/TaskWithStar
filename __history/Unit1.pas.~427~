unit Unit1;

interface

uses
  System.SysUtils;

type
  TServer = record
    FModel: array of string;
    FUptimeDay :integer;
    FServiceDate: integer;
    function AsBytes : TBytes;
    procedure SetBytes(buf:TBytes);
    procedure SaveRecordServer();
  end;

  TServiceCentr = record
    FDetails : array of string;
    FDeliveryTimeDay : integer;
    FBill : integer;
    function AsBytes : TBytes;
    procedure SetBytes(buf:TBytes);
    procedure SaveRecordService();
  end;

  TServiceEngineer = record
    FName : array of string;
    FSalary : integer;
    FExperience : integer;
    function AsBytes : TBytes;
    procedure SetBytes(buf:TBytes);
    procedure SaveRecordEngineer();
  end;

  TCount = class
    Server : TServer;
    ServiceCentr : TServiceCentr;
    ServiceEngineer : TServiceEngineer;
    Count: TCount;
    procedure SetModel();
    procedure SetUpTime();
    procedure SetServiceDate();
    procedure SetDetails();
    procedure SetDeliveryTime();
    procedure SetBill();
    procedure SetEngineerName();
    procedure SetSalary();
    procedure SetExperience();
    procedure SaveToText();
    procedure ReadFromText();
    constructor Create();
    destructor Destroy;
  end;

implementation

constructor TCount.Create();
begin

end;

destructor TCount.Destroy;
begin

end;

procedure TCount.ReadFromText;
  var
    TextRead: TextFile;
    str: string; 
  begin
    AssignFile(TextRead, 'C:\distr\Record.txt');
    Reset(TextRead);
    while not eof(TextRead) do
      begin
        Readln(TextRead, str);
        writeln(str);
    end;
    Close(TextRead);
  end;

procedure TCount.SetBill();
  var
    Price : integer;
  begin
    Writeln('Счет: ');
    readln(Price);
    ServiceCentr.FBill := Price;
  end;

procedure TCount.SetDeliveryTime;
  var
    DeliveryDay : integer;
  begin
    Writeln('Дней до доставки: : ');
    readln(DeliveryDay);
    ServiceCentr.FDeliveryTimeDay := DeliveryDay;
  end;

procedure TCount.SetDetails;
    var
    i ,y : integer;
    x, Quantity: string;
    flag: boolean;
  begin
    flag := true;
    i := 0;
    Writeln('Кол-во деталей: ');
    readln(Quantity);
    try
      Y:= StrToInt(Quantity) - 1;
    except
      Writeln('No');
      flag := False;
    end;

    if not flag then
    begin
      SetEngineerName;
      exit;
    end;

    Writeln('Введите наименование: ');
    for I := 0 to y do
    begin
      readln(x);
      ServiceCentr.FDetails := ServiceCentr.FDetails + [x];
    end;

  end;


procedure TCount.SetEngineerName();
  var
    i ,y : integer;
    x, Quantity: string;
    flag: boolean;
  begin
    flag := true;
    i := 0;
    Writeln('Кол-во сотурдников: ');
    readln(Quantity);                              //Вводим размер массива
    try
      Y:= StrToInt(Quantity) - 1;
    except
      Writeln('No');
      flag := False;
    end;

    if not flag then
    begin
      SetEngineerName;                    //рекурсия
      exit;
    end;

    Writeln('Введите имена: ');
    for I := 0 to y do
    begin
      readln(x);                                  //Ввод эодного лемента массива
      ServiceEngineer.FName := ServiceEngineer.FName + [x];  // Присваивание Фнейму его же значение плюс новый элемент массива веденный с клавиатуры
    end;

  end;

procedure TCount.SetExperience();
  var
    Exp: string;
    number : integer;
    flag: boolean;
  begin
    flag:= true;
    Writeln('Стаж: ');
    Readln(Exp);

    try
      number:= StrToInt(Exp);
    except
      Writeln('Введены некоректные данные:');
      flag := false;
    end;

    if not flag  then
     begin
     SetExperience;
     exit;
     end;

    ServiceEngineer.FExperience := number;
  end;

procedure TCount.SetModel();
  var
    i,x,number : integer;
    s,y : string;
    flag: boolean;
  begin
    i := 0;
    flag := true;
    Writeln('Количество серверов: ');
    readln(s);
      try
        number:= StrToInt(s) - 1;
      except
        Writeln('Введены некоректные данные:');
        flag:= false;
      end;

    if not flag then
      begin
        SetModel;
        exit
      end;

    Writeln('Введите модели: ');
    for I := 0 to number do
    begin
    readln(y);
    Server.FModel := Server.FModel + [y];
    end;
  end;

procedure TCount.SetSalary();
  var
    Salary : string;
    number : integer;
    flag: boolean;
  begin
    flag := true;
    Writeln('ЗП: ');
    readln(Salary);
    try
      number:= StrToInt(Salary);
    except
      Writeln('Введены некоректные данные:');
      flag:= false;
    end;

    if not flag then
      begin
        SetSalary;
        exit;
      end;

    ServiceEngineer.FSalary := number;
  end;

procedure TCount.SetServiceDate();
  var
    DateDay: integer;
  begin
    Writeln('Через сколько дней обсуживание: ');
    readln(DateDay);
    try

    except

    end;
    Server.FServiceDate:= DateDay;
  end;

procedure TCount.SetUpTime();
  var
    Days : integer;
  begin
    Writeln('Время рааботы сервера (Дни): ');
    readln(Days);
    Server.FUptimeDay:= Days;
  end;

procedure TCount.SaveToText;
  var
    TextForSave : TextFile;
    i : integer;
    str : string;
  begin
    AssignFile(TextForSave, 'C:\Distr\Record.txt');   //привязка файла к переменной
    if not FileExists('C:\Distr\Record.txt') then     //если файла нет то
      Rewrite(TextForSave);                           //Создать его
    Append(TextForSave);                              //Добавить в конец строки
    //Engineer                                        
    for str in ServiceEngineer.FName do               //Перебор значений в массиве
    Writeln(TextForSave, str);                        //Вывод элементов массива
    Writeln(TextForSave, ServiceEngineer.FSalary);
    Writeln(TextForSave, ServiceEngineer.FExperience); 
    //Model   
    for str in Server.FModel do
    Writeln(TextForSave, str);
    Writeln(TextForSave, Server.FUptimeDay);
    Writeln(TextForSave, Server.FServiceDate);
    //Service
    for str in ServiceCentr.FDetails do
    Writeln(TextForSave, str);
    Writeln(TextForSave, ServiceCentr.FDeliveryTimeDay);
    Writeln(TextForSave, ServiceCentr.FBill);
    Close(TextForSave);
  end;

{ TServer }

function TServer.AsBytes: TBytes;
  var
    Counter, size,ArrayLength: integer;
    str:string;
    data: TBytes;
  begin
    ArrayLength:= Length(FModel);
    size := SizeOF(ArrayLength) + SizeOF(FUptimeDay) + SizeOF(FServiceDate);
    for str in FModel do
    begin
      inc(size,Length(str)+ SizeOf(integer)); //+
    end;
    setlength(result,size);

    Counter :=0;

    Move(arrayLength,Result[counter],sizeOf(arrayLength));
    inc(counter,sizeOf(arrayLength));

    for str in FModel do
    begin
      Size := Length(str);
      Move(Size,Result[counter],sizeOf(Size));
      inc(counter,SizeOf(Size));
      data := TENcoding.UTF8.GetBytes(str);
      Move(data[0],Result[counter],length(data));
      inc(counter,length(data));
    end;

    Move(FUptimeDay,Result[counter],sizeOf(FUptimeDay));
    inc(counter,sizeOf(FUptimeDay));
    Move(FServiceDate,Result[counter],sizeOf(FServiceDate));
  end;

procedure TServer.SaveRecordServer;
  var
    ByteFileServer : File;
    count:integer;
    buf : TBytes;
  begin
    AssignFile(ByteFileServer,'C:\distr\NoTypeServer');
    if not FileExists('C:\distr\NoTypeServer') then
      Rewrite(ByteFileServer,1);
    Reset(ByteFileServer,1);
    buf:=Self.AsBytes;
    BlockWrite(ByteFileServer, buf[0], Length(buf));
    Close(ByteFileServer);
  end;

procedure TServer.SetBytes(buf: TBytes);
  var
    Counter, sizeArray,sizeStr: integer;
    ByteFileServer : File;
    data: TBytes;
  begin

    AssignFile(ByteFileServer, 'C:\distr\NoTypeServer');
    FileMode := fmOpenRead;
    Reset(ByteFileServer,1);
    SetLength(data,filesize(ByteFileServer));
    BlockRead(ByteFileServer,data[0],filesize(ByteFileServer));
    Counter := 0;
    Move(data[Counter],sizeArray, SizeOF(integer));
    SetLength(FModel, sizeArray);
    inc(Counter,SizeOf(integer));

      for var i:=0 to sizeArray-1 do
      begin
        Move(data[Counter], sizeStr,sizeOf(integer));
        inc(counter,SizeOf(integer));
        FModel[i]:= Tencoding.UTF8.GetString(Copy(data,Counter,sizeStr));
        inc(counter,sizeStr);
      end;

    Move(data[Counter],FUptimeDay, SizeOF(FUptimeDay));
    inc(Counter,SizeOf(FUptimeDay));

    Move(data[Counter],FServiceDate, SizeOF(FServiceDate));

    Close(ByteFileServer);
  end;

{ TServiceCentr }

function TServiceCentr.AsBytes: TBytes;
    var
    Counter, sizeArr, sizeStr, ArrayLength: integer;
    str: string;
    data: TBytes;
  begin
    ArrayLength:= Length(FDetails);     //узнаем количество элементов в массиве
    sizeArr:= sizeof(ArrayLength) + SizeOf(FDeliveryTimeDay) + SizeOf(FBill); //узнаю размер массива в байтах
    for str in FDetails do       //перебираем элементы в Фдетеилс выделяя место под каждый элемент
    begin
      inc(sizeArr,Length(str)+ SizeOf(integer));
    end;
    setlength(result,sizeArr);   // назначаем размерность массива на значения сизе
    Counter:= 0;       //ставим счетчик на первый элемент массива
    Move(arrayLength,Result[counter],sizeOf(arrayLength));
    inc(counter,sizeOf(arrayLength));          // увеличиваем счетчик
    for str in FDetails do
      begin
        Sizestr := Length(str);
        Move(sizestr,Result[counter],sizeOf(Sizestr));
        inc(counter,SizeOf(Sizestr));

        data:= TEncoding.UTF8.GetBytes(str);//записываем строку в дату  //тут, записывает только один элемент
        Move(data[0],Result[counter],length(data));
        inc(counter,length(data));

      end;


    Move(FDeliveryTimeDay,Result[counter],sizeOf(FDeliveryTimeDay));
    inc(counter,sizeOf(FDeliveryTimeDay));
    Move(FBill,Result[counter],sizeOf(FBill));

  end;

  procedure TServiceCentr.SaveRecordService;
  var
    ByteFileService : File;
    count:integer;
    buf : TBytes;
  begin
    AssignFile(ByteFileService,'C:\distr\NoTypeService');
    if not FileExists('C:\distr\NoTypeService') then
      Rewrite(ByteFileService,1);
    Reset(ByteFileService,1);
    buf:=Self.AsBytes;
    BlockWrite(ByteFileService, buf[0], Length(buf));
    Close(ByteFileService);
  end;

procedure TServiceCentr.SetBytes(buf: TBytes);     //При значении 1 все срабатывает при значении выше счетчик не дотягивается до массива
  var
    Counter, sizeArr,sizeStr,x: integer;
    str: string;
    ByteFileService : File;
    data: TBytes;
  begin
    AssignFile(ByteFileService,'C:\distr\NoTypeService');
    FileMode:= fmOpenRead;
    Reset(ByteFileService,1);
    SetLength(data,filesize(ByteFileService));
    BlockRead(ByteFileService,data[0],filesize(ByteFileService));

    Counter := 0;

    Move(data[Counter],sizeArr, SizeOF(integer));
    SetLength(Fdetails,sizeArr);
    inc(Counter,SizeOf(integer));

    for var i := 0 to sizeArr - 1 do
      begin
        Move(data[Counter],sizeStr, SizeOF(integer));
        inc(Counter,sizeof(integer));  //sizeof(integer)

        FDetails[i] := Tencoding.UTF8.GetString(Copy(data,Counter,sizestr));
        inc(counter,sizestr);
      end;

    Move(data[Counter],FDeliveryTimeDay, SizeOF(FDeliveryTimeDay));
    inc(Counter,SizeOf(FDeliveryTimeDay));

    Move(data[Counter],FBill, SizeOF(FBill));
    close(ByteFileService);
  end;

{ TServiceEngineer }

function TServiceEngineer.AsBytes: TBytes;
    var
    Counter, size,ArrayLength: integer;
    str:string;
    data: TBytes;
  begin
    ArrayLength:= Length(FName);
    size := SizeOF(ArrayLength) + SizeOF(FSalary) + SizeOF(FExperience);
    for str in FName do
    begin
      inc(size,Length(str)+SizeOf(integer));
    end;
    setlength(result,size);

    Counter :=0;

    Move(arrayLength,Result[counter],sizeOf(arrayLength));
    inc(counter,sizeOf(arrayLength));

    for str in FName do
    begin
      Size := Length(str);
      Move(Size,Result[counter],sizeOf(Size));
      inc(counter,SizeOf(Size));

      data := TENcoding.UTF8.GetBytes(str);
      Move(data[0],Result[counter],length(data));
      inc(counter,length(data));
    end;

    Move(FSalary,Result[counter],sizeOf(FSalary));
    inc(counter,sizeOf(FSalary));

    Move(FExperience,Result[counter],sizeOf(FExperience));
  end;

procedure TServiceEngineer.SaveRecordEngineer;
  var
    ByteFileEngineer : File;
    count:integer;
    buf : TBytes;
  begin
    AssignFile(ByteFileEngineer,'C:\distr\NoTypeEngineer');
    if not FileExists('C:\distr\NoTypeEngineer') then
      Rewrite(ByteFileEngineer,1);
    Reset(ByteFileEngineer,1);
    buf:=Self.AsBytes;
    BlockWrite(ByteFileEngineer, buf, Length(buf));
    Close(ByteFileEngineer);
  end;

procedure TServiceEngineer.SetBytes(buf: TBytes);
  var
    Counter, sizeArray, sizeStr: integer;
    data: TBytes;
    ByteFileEngineer: file;
  begin

    AssignFile(ByteFileEngineer,'C:\distr\NoTypeEngineer');
    FileMode:= fmOpenRead;
    Reset(ByteFileEngineer,1);
    SetLength(data,filesize(ByteFileEngineer));
    BlockRead(ByteFileEngineer,data,filesize(ByteFileEngineer));
    Counter := 0;
    Move(data[Counter],sizeArray, SizeOF(integer));
    SetLength(FName, sizeArray);
    inc(Counter,SizeOf(integer));

     for var i := 0 to sizeArray - 1 do
      begin
        Move(data[Counter],sizeStr, SizeOF(integer));
        inc(Counter,sizeof(integer));  //sizeof(integer)
        FName[i] := Tencoding.UTF8.GetString(Copy(data,Counter,sizestr));
        inc(counter,sizestr);
      end;

    Move(data[Counter],FSalary, SizeOF(FSalary));
    inc(Counter,SizeOf(FSalary));

    Move(data[Counter],FExperience, SizeOF(FExperience));
    close(ByteFileEngineer);
  end;

end.
