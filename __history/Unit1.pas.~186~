unit Unit1;

interface

uses
  System.SysUtils;

type
  TServer = record
    FModel: array of string;
    FUptimeDay :integer;
    FServiceDate: integer;
    function AsBytes : TBytes;
    procedure SetBytes(buf:TBytes);
    procedure SaveRecordServer();
  end;

  TServiceCentr = record
    FDetails : array of string;
    FDeliveryTimeDay : integer;
    FBill : integer;
    function AsBytes : TBytes;
    procedure SetBytes(buf:TBytes);
    procedure SaveRecordService();
  end;

  TServiceEngineer = record
    FName : array of string;
    FSalary : integer;
    FExperience : integer;
    function AsBytes : TBytes;
    procedure SetBytes(buf:TBytes);
  end;

  TCount = class
    Server : TServer;
    ServiceCentr : TServiceCentr;
    ServiceEngineer : TServiceEngineer;
    Count: TCount;
    procedure SetModel();
    procedure SetUpTime();
    procedure SetServiceDate();
    procedure SetDetails();
    procedure SetDeliveryTime();
    procedure SetBill();
    procedure SetEngineerName();
    procedure SetSalary();
    procedure SetExperience();
    procedure SaveToText();
    procedure SaveToNoType();
    procedure ReadFromText();
//    function AsBytes : TBytes;
//    procedure SetBytes(Buf: Tbytes);
    constructor Create();
    destructor Destroy;
  end;

implementation

constructor TCount.Create();
begin

end;

destructor TCount.Destroy;
begin

end;

procedure TCount.ReadFromText;
  var
    TextRead: TextFile;
    str: string; 
  begin
    AssignFile(TextRead, 'C:\distr\Record.txt');
    Reset(TextRead);
    while not eof(TextRead) do
      begin
        Readln(TextRead, str);
        writeln(str);
    end;
    Close(TextRead);
  end;

procedure TCount.SetBill();
  var
    Price : integer;
  begin
    Writeln('Счет: ');
    readln(Price);
    ServiceCentr.FBill := Price;
  end;

procedure TCount.SetDeliveryTime;
  var
    DeliveryDay : integer;
  begin
    Writeln('Дней до доставки: : ');
    readln(DeliveryDay);
    ServiceCentr.FDeliveryTimeDay := DeliveryDay;
  end;

procedure TCount.SetDetails;
    var
    i ,y : integer;
    x, Quantity: string;
    flag: boolean;
  begin
    flag := true;
    i := 0;
    Writeln('Кол-во деталей: ');
    readln(Quantity);
    try
      Y:= StrToInt(Quantity) - 1;
    except
      Writeln('No');
      flag := False;
    end;

    if not flag then
    begin
      SetEngineerName;
      exit;
    end;

    Writeln('Введите наименование: ');
    for I := 0 to y do
    begin
      readln(x);
      ServiceCentr.FDetails := ServiceCentr.FDetails + [x];
    end;

  end;


procedure TCount.SetEngineerName();
  var
    i ,y : integer;
    x, Quantity: string;
    flag: boolean;
  begin
    flag := true;
    i := 0;
    Writeln('Кол-во сотурдников: ');
    readln(Quantity);                              //Вводим размер массива
    try
      Y:= StrToInt(Quantity) - 1;
    except
      Writeln('No');
      flag := False;
    end;

    if not flag then
    begin
      SetEngineerName;                    //рекурсия
      exit;
    end;

    Writeln('Введите имена: ');
    for I := 0 to y do
    begin
      readln(x);                                  //Ввод эодного лемента массива
      ServiceEngineer.FName := ServiceEngineer.FName + [x];  // Присваивание Фнейму его же значение плюс новый элемент массива веденный с клавиатуры
    end;

  end;

procedure TCount.SetExperience();
  var
    Exp: string;
    number : integer;
    flag: boolean;
  begin
    flag:= true;
    Writeln('Стаж: ');
    Readln(Exp);

    try
      number:= StrToInt(Exp);
    except
      Writeln('Введены некоректные данные:');
      flag := false;
    end;

    if not flag  then
     begin
     SetExperience;
     exit;
     end;

    ServiceEngineer.FExperience := number;
  end;

procedure TCount.SetModel();
  var
    i,x,number : integer;
    s : string;
    flag: boolean;
  begin
    i := 0;
    flag := true;
    Writeln('Количество серверов: ');
    readln(s);
      try
        number:= StrToInt(s) - 1;
      except
        Writeln('Введены некоректные данные:');
        flag:= false;
      end;

    if not flag then
      begin
        SetModel;
        exit
      end;

    Writeln('Введите модели: ');
    for I := 0 to number do
    readln(s);
    Server.FModel := Server.FModel + [s];
  end;

procedure TCount.SetSalary();
  var
    Salary : string;
    number : integer;
    flag: boolean;
  begin
    flag := true;
    Writeln('ЗП: ');
    readln(Salary);
    try
      number:= StrToInt(Salary);
    except
      Writeln('Введены некоректные данные:');
      flag:= false;
    end;

    if not flag then
      begin
        SetSalary;
        exit;
      end;

    ServiceEngineer.FSalary := number;
  end;

procedure TCount.SetServiceDate();
  var
    DateDay: integer;
  begin
    Writeln('Через сколько дней обсуживание: ');
    readln(DateDay);
    try

    except

    end;
    Server.FServiceDate:= DateDay;
  end;

procedure TCount.SetUpTime();
  var
    Days : integer;
  begin
    Writeln('Время рааботы сервера (Дни): ');
    readln(Days);
    Server.FUptimeDay:= Days;
  end;

procedure TCount.SaveToText;
  var
    TextForSave : TextFile;
    i : integer;
    str : string;
  begin
    AssignFile(TextForSave, 'C:\Distr\Record.txt');   //привязка файла к переменной
    if not FileExists('C:\Distr\Record.txt') then     //если файла нет то
      Rewrite(TextForSave);                           //Создать его
    Append(TextForSave);                              //Добавить в конец строки
    //Engineer                                        
    for str in ServiceEngineer.FName do               //Перебор значений в массиве
    Writeln(TextForSave, str);                        //Вывод элементов массива
    Writeln(TextForSave, ServiceEngineer.FSalary);
    Writeln(TextForSave, ServiceEngineer.FExperience); 
    //Model   
    for str in Server.FModel do
    Writeln(TextForSave, str);
    Writeln(TextForSave, Server.FUptimeDay);
    Writeln(TextForSave, Server.FServiceDate);
    //Service
    for str in ServiceCentr.FDetails do
    Writeln(TextForSave, str);
    Writeln(TextForSave, ServiceCentr.FDeliveryTimeDay);
    Writeln(TextForSave, ServiceCentr.FBill);
    Close(TextForSave);
  end;

procedure TCount.SaveToNoType;
  var
    TextForByte : File;
    count:integer;
    buf : TBytes;
  begin
    AssignFile(TextForByte,'C:\distr\NoTypeFile');
    if not FileExists('C:\distr\NoTypeFile') then
      Rewrite(TextForByte,1);
    Reset(TextForByte,1);
//    buf:=AsBytes;
    BlockWrite(TextForByte, buf[0], Length(buf));
    Close(TextForByte);
  end;

//procedure TCount.SetBytes(Buf: Tbytes);
//  var
//  Counter, size:integer;
//  TextForByte : file;
//  begin
//    buf:=0;
//    Counter:= 0;
//    AssignFile(TextForByte, 'C:\distr\NoTypeFile');
//    Reset(TextForByte,1);
//    BlockRead(TexTForByte, buf[0], Length(buf));
//    Move(buf[Counter],Server.FUptimeDay, sizeof(Server.FUptimeDay));
//    inc(counter,sizeof(Server.FUptimeDay));
//
//    Move(buf[Counter], Server.FServiceDate, sizeof(Server.FServiceDate));
//    inc(Counter, sizeof(Server.FServiceDate));

//    Move(buf[Counter], Server.FServiceDate, sizeof(Server.FServiceDate));
//    inc(Counter, sizeof(integer));
//    Close(TextForByte);
//  end;

{ TServer }

function TServer.AsBytes: TBytes;
  var
    Counter, size,ArrayLength: integer;
    str:string;
    data: TBytes;
  begin
    ArrayLength:= Length(FModel);
    size := SizeOF(ArrayLength) + SizeOF(FUptimeDay) + SizeOF(FServiceDate);
    for str in FModel do
    begin
      inc(size,Length(str)+SizeOf(integer));
    end;
    setlength(result,size);

    Counter :=0;

    Move(arrayLength,Result[counter],sizeOf(arrayLength));
    inc(counter,sizeOf(arrayLength));

    for str in FModel do
    begin
      Size := Length(str);
      Move(Size,Result[counter],sizeOf(Size));
      inc(counter,SizeOf(Size));
      data := TENcoding.UTF8.GetBytes(str);
      Move(data[0],Result[counter],length(data));
      inc(counter,length(data));
    end;

    Move(FUptimeDay,Result[counter],sizeOf(FUptimeDay));
    inc(counter,sizeOf(FUptimeDay));
    Move(FServiceDate,Result[counter],sizeOf(FServiceDate));
  end;

procedure TServer.SaveRecordServer;
  var
    ByteFileServer : File;
    count:integer;
    buf : TBytes;
  begin
    AssignFile(ByteFileServer,'C:\distr\NoTypeServer');
    if not FileExists('C:\distr\NoTypeServer') then
      Rewrite(ByteFileServer,1);
    Reset(ByteFileServer,1);
    buf:=Self.AsBytes;
    BlockWrite(ByteFileServer, buf[0], Length(buf));
    Close(ByteFileServer);
  end;

procedure TServer.SetBytes(buf: TBytes);
begin

end;

{ TServiceCentr }

function TServiceCentr.AsBytes: TBytes;
    var
    Counter, size, ArrayLength: integer;
    str: string;
    data: TBytes;
  begin
    ArrayLength:= Length(FDetails);     //узнаем количество элементов в массиве
    size:= SizeOf(ArrayLength) + SizeOf(FDeliveryTimeDay) + SizeOf(FBill); //узнаю размер массива в байтах
    for str in FDetails do       //перебираем элементы в Фдетеилс
    begin
      inc(size,Length(str)+SizeOf(integer));
    end;
    setlength(result,size);   // назначаем размерность массива на значения сизе
    Counter:= 0;       //ставим счетчик на первый элемент массива
    Move(arrayLength,Result[counter],sizeOf(arrayLength));
    inc(counter,sizeOf(arrayLength));          // увеличиваем счетчик
    for str in FDetails do
      begin
        Size := Length(str);
        Move(Size,Result[counter],sizeOf(Size));
        inc(counter,SizeOf(Size));
      end;
    data:= TEncoding.UTF8.GetBytes(str);      //записываем строку в дату
    Move(data[0],Result[counter],length(data));
    inc(counter,length(data));
    Move(FDeliveryTimeDay,Result[counter],sizeOf(FDeliveryTimeDay));
    inc(counter,sizeOf(FDeliveryTimeDay));
    Move(FBill,Result[counter],sizeOf(FBill));

  end;

  procedure TServiceCentr.SaveRecordService;
  var
    ByteFileService : File;
    count:integer;
    buf : TBytes;
  begin
    AssignFile(ByteFileService,'C:\distr\NoTypeService');
    if not FileExists('C:\distr\NoTypeService') then
      Rewrite(ByteFileService,1);
    Reset(ByteFileService,1);
    buf:=Self.AsBytes;
    BlockWrite(ByteFileService, buf[0], Length(buf));
    Close(ByteFileService);
  end;

procedure TServiceCentr.SetBytes(buf: TBytes);
begin

end;

{ TServiceEngineer }

function TServiceEngineer.AsBytes: TBytes;
    var
    Counter, size,ArrayLength: integer;
    str:string;
    data: TBytes;
  begin
    ArrayLength:= Length(FName);
    size := SizeOF(ArrayLength) + SizeOF(FSalary) + SizeOF(FExperience);
    for str in FName do
    begin
      inc(size,Length(str)+SizeOf(integer));
    end;
    setlength(result,size);

    Counter :=0;

    Move(arrayLength,Result[counter],sizeOf(arrayLength));
    inc(counter,sizeOf(arrayLength));

    for str in FName do
    begin
      Size := Length(str);
      Move(Size,Result[counter],sizeOf(Size));
      inc(counter,SizeOf(Size));

      data := TENcoding.UTF8.GetBytes(str);
      Move(data[0],Result[counter],length(data));
      inc(counter,length(data));
    end;

    Move(FSalary,Result[counter],sizeOf(FSalary));
    inc(counter,sizeOf(FSalary));

    Move(FExperience,Result[counter],sizeOf(FExperience));
  end;

procedure TServiceEngineer.SetBytes(buf: TBytes);
begin

end;

end.
